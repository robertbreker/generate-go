func (self *VM) GetDisks() (vdis []*VDI, err error) {
	// Return just data disks (non-isos)
	vdis = make([]*VDI, 0)
	vbds, err := self.GetVBDs()
	if err != nil {
		return nil, err
	}

	for _, vbd := range vbds {
		rec, err := vbd.GetRecord()
		if err != nil {
			return nil, err
		}
		if rec["type"] == "Disk" {

			vdi, err := vbd.GetVDI()
			if err != nil {
				return nil, err
			}
			vdis = append(vdis, vdi)

		}
	}
	return vdis, nil
}

func (self *VM) SetStaticMemoryRange(min, max uint64) (err error) {
	result := APIResult{}
	strMin := fmt.Sprintf("%d", min)
	strMax := fmt.Sprintf("%d", max)
	err = self.Client.APICall(&result, "VM.set_memory_limits", self.Ref, strMin, strMax, strMin, strMax)
	if err != nil {
		return err
	}
	return
}

func (self *VM) ConnectVdi(vdi *VDI, vdiType VDIType, userdevice string) (err error) {

	// 1. Create a VBD
	if userdevice == "" {
		userdevice = "autodetect"
	}

	vbd_rec := make(xmlrpc.Struct)
	vbd_rec["VM"] = self.Ref
	vbd_rec["VDI"] = vdi.Ref
	vbd_rec["userdevice"] = userdevice
	vbd_rec["empty"] = false
	vbd_rec["other_config"] = make(xmlrpc.Struct)
	vbd_rec["qos_algorithm_type"] = ""
	vbd_rec["qos_algorithm_params"] = make(xmlrpc.Struct)

	switch vdiType {
	case CD:
		vbd_rec["mode"] = "RO"
		vbd_rec["bootable"] = true
		vbd_rec["unpluggable"] = false
		vbd_rec["type"] = "CD"
	case Disk:
		vbd_rec["mode"] = "RW"
		vbd_rec["bootable"] = false
		vbd_rec["unpluggable"] = false
		vbd_rec["type"] = "Disk"
	case Floppy:
		vbd_rec["mode"] = "RW"
		vbd_rec["bootable"] = false
		vbd_rec["unpluggable"] = true
		vbd_rec["type"] = "Floppy"
	}

	result := APIResult{}
	err = self.Client.APICall(&result, "VBD.create", vbd_rec)

	if err != nil {
		return err
	}

	vbd_ref := result.Value.(string)

	result = APIResult{}
	err = self.Client.APICall(&result, "VBD.get_uuid", vbd_ref)

	/*
	   // 2. Plug VBD (Non need - the VM hasn't booted.
	   // @todo - check VM state
	   result = APIResult{}
	   err = self.Client.APICall(&result, "VBD.plug", vbd_ref)
	   if err != nil {
	       return err
	   }
	*/
	return
}

func (self *VM) DisconnectVdi(vdi *VDI) error {
	vbds, err := self.GetVBDs()
	if err != nil {
		return fmt.Errorf("Unable to get VM VBDs: %s", err.Error())
	}

	for _, vbd := range vbds {
		rec, err := vbd.GetRecord()
		if err != nil {
			return fmt.Errorf("Could not get record for VBD '%s': %s", vbd.Ref, err.Error())
		}

		if recVdi, ok := rec["VDI"].(string); ok {
			if recVdi == vdi.Ref {
				_ = vbd.Unplug()
				err = vbd.Destroy()
				if err != nil {
					return fmt.Errorf("Could not destroy VBD '%s': %s", vbd.Ref, err.Error())
				}

				return nil
			}
		}
	}

	return fmt.Errorf("Could not find VBD for VDI '%s'", vdi.Ref)
}

func (self *VM) ConnectNetwork(network *Network, device string) (vif *VIF, err error) {
	// Create the VIF

	vif_rec := make(xmlrpc.Struct)
	vif_rec["network"] = network.Ref
	vif_rec["VM"] = self.Ref
	vif_rec["MAC"] = ""
	vif_rec["device"] = device
	vif_rec["MTU"] = "1504"
	vif_rec["other_config"] = make(xmlrpc.Struct)
	vif_rec["MAC_autogenerated"] = true
	vif_rec["locking_mode"] = "network_default"
	vif_rec["qos_algorithm_type"] = ""
	vif_rec["qos_algorithm_params"] = make(xmlrpc.Struct)

	result := APIResult{}
	err = self.Client.APICall(&result, "VIF.create", vif_rec)

	if err != nil {
		return nil, err
	}

	vif = new(VIF)
	vif.Ref = result.Value.(string)
	vif.Client = self.Client

	return vif, nil
}
